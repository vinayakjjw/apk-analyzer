{"file_contents":{"apk_analyzer.py":{"content":"import os\nimport zipfile\nimport xml.etree.ElementTree as ET\nfrom androguard.core.apk import APK\nfrom signature_analyzer import SignatureAnalyzer\nimport re\n\nclass APKAnalyzer:\n    def __init__(self, apk_path):\n        self.apk_path = apk_path\n        self.apk_obj = None\n        self.file_size = os.path.getsize(apk_path)\n        \n    def analyze(self):\n        \"\"\"Perform comprehensive APK analysis\"\"\"\n        try:\n            self.apk_obj = APK(self.apk_path)\n            \n            analysis_data = {\n                'file_size': self.file_size,\n                'app_name': self._get_app_name(),\n                'package_name': self._get_package_name(),\n                'version_name': self._get_version_name(),\n                'version_code': self._get_version_code(),\n                'min_sdk_version': self._get_min_sdk_version(),\n                'target_sdk_version': self._get_target_sdk_version(),\n                'debuggable': self._is_debuggable(),\n                'architectures': self._get_architectures(),\n                'supported_screens': self._get_supported_screens(),\n                'supported_densities': self._get_supported_densities(),\n                'permissions': self._analyze_permissions(),\n                'features': self._analyze_features(),\n                'signature': self._analyze_signature(),\n                'unity_exported': self._check_unity_exported(),\n                'activities': self._get_activities(),\n                'services': self._get_services(),\n                'receivers': self._get_receivers(),\n                'providers': self._get_providers(),\n                'app_icon': self._get_app_icon(),\n                'manifest_xml': self._get_manifest_xml()\n            }\n            \n            return analysis_data\n            \n        except Exception as e:\n            raise Exception(f\"Failed to analyze APK: {str(e)}\")\n    \n    def _get_app_name(self):\n        \"\"\"Extract application name\"\"\"\n        try:\n            return self.apk_obj.get_app_name() or \"Unknown\"\n        except:\n            return \"Unknown\"\n    \n    def _get_package_name(self):\n        \"\"\"Extract package name\"\"\"\n        try:\n            return self.apk_obj.get_package() or \"Unknown\"\n        except:\n            return \"Unknown\"\n    \n    def _get_version_name(self):\n        \"\"\"Extract version name\"\"\"\n        try:\n            return self.apk_obj.get_androidversion_name() or \"Unknown\"\n        except:\n            return \"Unknown\"\n    \n    def _get_version_code(self):\n        \"\"\"Extract version code\"\"\"\n        try:\n            return self.apk_obj.get_androidversion_code() or \"Unknown\"\n        except:\n            return \"Unknown\"\n    \n    def _get_min_sdk_version(self):\n        \"\"\"Extract minimum SDK version\"\"\"\n        try:\n            return self.apk_obj.get_min_sdk_version() or \"Unknown\"\n        except:\n            return \"Unknown\"\n    \n    def _get_target_sdk_version(self):\n        \"\"\"Extract target SDK version\"\"\"\n        try:\n            return self.apk_obj.get_target_sdk_version() or \"Unknown\"\n        except:\n            return \"Unknown\"\n    \n    def _is_debuggable(self):\n        \"\"\"Check if application is debuggable\"\"\"\n        try:\n            manifest = self.apk_obj.get_android_manifest_xml()\n            for elem in manifest.iter():\n                if elem.tag == 'application':\n                    debuggable = elem.get('{http://schemas.android.com/apk/res/android}debuggable')\n                    return debuggable == 'true'\n            return False\n        except:\n            return False\n    \n    def _get_architectures(self):\n        \"\"\"Extract supported architectures\"\"\"\n        try:\n            with zipfile.ZipFile(self.apk_path, 'r') as z:\n                files = z.namelist()\n                architectures = set()\n                \n                for file in files:\n                    if file.startswith('lib/'):\n                        parts = file.split('/')\n                        if len(parts) >= 2:\n                            arch = parts[1]\n                            if arch in ['arm64-v8a', 'armeabi-v7a', 'armeabi', 'x86', 'x86_64', 'mips', 'mips64']:\n                                architectures.add(arch)\n                \n                return ', '.join(sorted(architectures)) if architectures else \"Universal\"\n        except:\n            return \"Unknown\"\n    \n    def _get_supported_screens(self):\n        \"\"\"Extract supported screen sizes\"\"\"\n        try:\n            manifest = self.apk_obj.get_android_manifest_xml()\n            screens = []\n            \n            for elem in manifest.iter():\n                if elem.tag == 'supports-screens':\n                    for attr, value in elem.attrib.items():\n                        if value == 'true':\n                            screen_type = attr.split('}')[-1] if '}' in attr else attr\n                            screens.append(screen_type)\n            \n            return screens if screens else [\"All screens (default)\"]\n        except:\n            return []\n    \n    def _get_supported_densities(self):\n        \"\"\"Extract supported screen densities\"\"\"\n        try:\n            with zipfile.ZipFile(self.apk_path, 'r') as z:\n                files = z.namelist()\n                densities = set()\n                \n                density_folders = ['ldpi', 'mdpi', 'hdpi', 'xhdpi', 'xxhdpi', 'xxxhdpi', 'tvdpi', 'nodpi']\n                \n                for file in files:\n                    for density in density_folders:\n                        if f'drawable-{density}/' in file or f'mipmap-{density}/' in file:\n                            densities.add(density)\n                \n                return sorted(densities) if densities else [\"All densities\"]\n        except:\n            return []\n    \n    def _analyze_permissions(self):\n        \"\"\"Analyze all types of permissions\"\"\"\n        try:\n            declared = self.apk_obj.get_declared_permissions() or []\n            \n            # Get implied permissions (basic analysis)\n            implied = self._get_implied_permissions()\n            \n            # Get optional permissions\n            optional = self._get_optional_permissions()\n            \n            return {\n                'declared': declared,\n                'implied': implied,\n                'optional': optional\n            }\n        except:\n            return {'declared': [], 'implied': [], 'optional': []}\n    \n    def _get_implied_permissions(self):\n        \"\"\"Get permissions that are implied by other permissions or features\"\"\"\n        implied = []\n        try:\n            permissions = self.apk_obj.get_declared_permissions() or []\n            \n            # Some basic implied permission rules\n            if 'android.permission.WRITE_EXTERNAL_STORAGE' in permissions:\n                implied.append('android.permission.READ_EXTERNAL_STORAGE')\n            \n            if 'android.permission.ACCESS_FINE_LOCATION' in permissions:\n                implied.append('android.permission.ACCESS_COARSE_LOCATION')\n                \n        except:\n            pass\n        return implied\n    \n    def _get_optional_permissions(self):\n        \"\"\"Get optional permissions from manifest\"\"\"\n        optional = []\n        try:\n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for elem in manifest.iter():\n                if elem.tag == 'uses-permission':\n                    required = elem.get('{http://schemas.android.com/apk/res/android}required')\n                    if required == 'false':\n                        name = elem.get('{http://schemas.android.com/apk/res/android}name')\n                        if name:\n                            optional.append(name)\n        except:\n            pass\n        return optional\n    \n    def _analyze_features(self):\n        \"\"\"Analyze required, implied, and not-required features\"\"\"\n        try:\n            required = []\n            implied = []\n            not_required = []\n            opengl_version = None\n            \n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for elem in manifest.iter():\n                if elem.tag == 'uses-feature':\n                    name = elem.get('{http://schemas.android.com/apk/res/android}name')\n                    required_attr = elem.get('{http://schemas.android.com/apk/res/android}required')\n                    gl_es_version = elem.get('{http://schemas.android.com/apk/res/android}glEsVersion')\n                    \n                    if name:\n                        if required_attr == 'false':\n                            not_required.append(name)\n                        else:\n                            required.append(name)\n                    \n                    # Extract OpenGL ES version\n                    if gl_es_version:\n                        try:\n                            # Convert hex version to readable format\n                            version_int = int(gl_es_version, 16) if gl_es_version.startswith('0x') else int(gl_es_version)\n                            major = (version_int >> 16) & 0xFFFF\n                            minor = version_int & 0xFFFF\n                            opengl_version = f\"OpenGL ES {major}.{minor}\"\n                        except:\n                            opengl_version = f\"OpenGL ES (version: {gl_es_version})\"\n            \n            # Get implied features based on permissions\n            implied = self._get_implied_features()\n            \n            return {\n                'required': required,\n                'implied': implied,\n                'not_required': not_required,\n                'opengl_version': opengl_version\n            }\n        except:\n            return {'required': [], 'implied': [], 'not_required': [], 'opengl_version': None}\n    \n    def _get_implied_features(self):\n        \"\"\"Get features that are implied by permissions\"\"\"\n        implied = []\n        try:\n            permissions = self.apk_obj.get_declared_permissions() or []\n            \n            # Basic implied feature mappings\n            feature_mappings = {\n                'android.permission.CAMERA': 'android.hardware.camera',\n                'android.permission.ACCESS_FINE_LOCATION': 'android.hardware.location.gps',\n                'android.permission.ACCESS_COARSE_LOCATION': 'android.hardware.location.network',\n                'android.permission.RECORD_AUDIO': 'android.hardware.microphone',\n                'android.permission.BLUETOOTH': 'android.hardware.bluetooth',\n                'android.permission.BLUETOOTH_ADMIN': 'android.hardware.bluetooth',\n                'android.permission.ACCESS_WIFI_STATE': 'android.hardware.wifi',\n                'android.permission.CHANGE_WIFI_STATE': 'android.hardware.wifi',\n            }\n            \n            for perm in permissions:\n                if perm in feature_mappings:\n                    feature = feature_mappings[perm]\n                    if feature not in implied:\n                        implied.append(feature)\n                        \n        except:\n            pass\n        return implied\n    \n    def _analyze_signature(self):\n        \"\"\"Analyze APK signature\"\"\"\n        try:\n            # Try to use androguard's built-in certificate methods first\n            signature_data = {\n                'signer': 'Unknown',\n                'valid_from': 'Unknown',\n                'valid_until': 'Unknown',\n                'algorithm': 'Unknown',\n                'sha256_digest': 'Unknown',\n                'sha1_digest': 'Unknown',\n                'md5_digest': 'Unknown',\n                'schemes': {\n                    'v1 (JAR signing)': False,\n                    'v2 (APK Signature Scheme v2)': False,\n                    'v3 (APK Signature Scheme v3)': False,\n                    'v3.1 (APK Signature Scheme v3.1)': False,\n                    'v4 (APK Signature Scheme v4)': False\n                }\n            }\n            \n            # Use androguard's certificate methods with proper error handling\n            try:\n                # Try to get certificates using different methods\n                cert_der = None\n                try:\n                    cert_der = self.apk_obj.get_certificate_der(0)\n                except:\n                    try:\n                        # Alternative method\n                        certs_der = self.apk_obj.get_certificates_der_v2()\n                        if certs_der:\n                            cert_der = certs_der[0]\n                    except:\n                        try:\n                            # V1 method\n                            certs_v1 = self.apk_obj.get_certificates_v1()\n                            if certs_v1:\n                                cert_der = certs_v1[0]\n                        except:\n                            pass\n\n                if cert_der:\n                    from cryptography import x509\n                    import hashlib\n                    \n                    cert = x509.load_der_x509_certificate(cert_der)\n                    \n                    # Calculate certificate fingerprints from DER data\n                    sha256_digest = hashlib.sha256(cert_der).hexdigest()\n                    sha1_digest = hashlib.sha1(cert_der).hexdigest()\n                    md5_digest = hashlib.md5(cert_der).hexdigest()\n                    \n                    # Format fingerprints with colons for readability\n                    sha256_formatted = ':'.join(sha256_digest[i:i+2] for i in range(0, len(sha256_digest), 2)).upper()\n                    sha1_formatted = ':'.join(sha1_digest[i:i+2] for i in range(0, len(sha1_digest), 2)).upper()\n                    md5_formatted = ':'.join(md5_digest[i:i+2] for i in range(0, len(md5_digest), 2)).upper()\n                    \n                    # Extract certificate information\n                    subject = cert.subject.rfc4514_string()\n                    # Use UTC timezone-aware methods to avoid deprecation warnings\n                    try:\n                        valid_from = cert.not_valid_before_utc.strftime('%Y-%m-%d %H:%M:%S UTC')\n                        valid_until = cert.not_valid_after_utc.strftime('%Y-%m-%d %H:%M:%S UTC')\n                    except AttributeError:\n                        # Fallback for older cryptography versions\n                        valid_from = cert.not_valid_before.strftime('%Y-%m-%d %H:%M:%S UTC')\n                        valid_until = cert.not_valid_after.strftime('%Y-%m-%d %H:%M:%S UTC')\n                    \n                    # Extract CN from subject\n                    subject_cn = \"Unknown\"\n                    try:\n                        for attribute in cert.subject:\n                            if attribute.oid._name == 'commonName':\n                                subject_cn = attribute.value\n                                break\n                    except:\n                        # Try alternative extraction\n                        subject_parts = subject.split(',')\n                        for part in subject_parts:\n                            if 'CN=' in part:\n                                subject_cn = part.split('CN=')[1].strip()\n                                break\n                    \n                    # Get algorithm name\n                    try:\n                        algo_name = cert.signature_algorithm_oid._name\n                        if 'sha256' in algo_name.lower():\n                            if 'rsa' in algo_name.lower():\n                                algorithm = 'RSA with SHA-256'\n                            elif 'ecdsa' in algo_name.lower():\n                                algorithm = 'ECDSA with SHA-256'\n                            else:\n                                algorithm = algo_name\n                        else:\n                            algorithm = algo_name\n                    except:\n                        algorithm = \"Unknown\"\n                    \n                    signature_data.update({\n                        'signer': subject,  # Use full subject for detailed display\n                        'signer_cn': subject_cn,  # Keep CN for simple display\n                        'valid_from': valid_from,\n                        'valid_until': valid_until,\n                        'algorithm': algorithm,\n                        'subject': subject,\n                        'sha256_digest': sha256_formatted,\n                        'sha1_digest': sha1_formatted,\n                        'md5_digest': md5_formatted\n                    })\n                        \n            except Exception as cert_error:\n                # Log error for debugging but continue\n                print(f\"Certificate parsing error: {cert_error}\")\n                # Try to get basic signature info without certificate details\n                try:\n                    sig_names = self.apk_obj.get_signature_names()\n                    if sig_names:\n                        signature_data['signer'] = f\"Certificate: {sig_names[0]}\"\n                except:\n                    pass\n            \n            # Check signature schemes using androguard methods\n            try:\n                signature_data['schemes']['v1 (JAR signing)'] = self.apk_obj.is_signed_v1()\n                signature_data['schemes']['v2 (APK Signature Scheme v2)'] = self.apk_obj.is_signed_v2()\n                signature_data['schemes']['v3 (APK Signature Scheme v3)'] = self.apk_obj.is_signed_v3()\n            except Exception:\n                # If androguard methods fail, use fallback analyzer\n                signature_analyzer = SignatureAnalyzer(self.apk_path)\n                fallback_data = signature_analyzer.analyze()\n                if 'schemes' in fallback_data:\n                    signature_data['schemes'] = fallback_data['schemes']\n            \n            return signature_data\n            \n        except Exception as e:\n            # Complete fallback to signature analyzer\n            try:\n                signature_analyzer = SignatureAnalyzer(self.apk_path)\n                return signature_analyzer.analyze()\n            except:\n                return {'error': str(e)}\n    \n    def _check_unity_exported(self):\n        \"\"\"Check if Unity main activity has android:exported='true'\"\"\"\n        try:\n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for activity in manifest.iter('activity'):\n                name = activity.get('{http://schemas.android.com/apk/res/android}name')\n                \n                # Check for Unity activity patterns\n                if name and ('UnityPlayerActivity' in name or 'MainActivity' in name):\n                    # Check if this looks like a Unity app\n                    if self._is_unity_app():\n                        exported = activity.get('{http://schemas.android.com/apk/res/android}exported')\n                        return exported == 'true'\n            \n            return None  # Not a Unity app or activity not found\n        except:\n            return None\n    \n    def _is_unity_app(self):\n        \"\"\"Check if this is a Unity application\"\"\"\n        try:\n            with zipfile.ZipFile(self.apk_path, 'r') as z:\n                files = z.namelist()\n                \n                # Look for Unity-specific files\n                unity_indicators = [\n                    'assets/bin/Data/unity default resources',\n                    'lib/armeabi-v7a/libunity.so',\n                    'lib/arm64-v8a/libunity.so',\n                    'assets/bin/Data/globalgamemanagers',\n                    'assets/bin/Data/level0'\n                ]\n                \n                for indicator in unity_indicators:\n                    if indicator in files:\n                        return True\n                        \n                # Also check for libunity.so in any architecture\n                for file in files:\n                    if 'libunity.so' in file:\n                        return True\n                        \n                return False\n        except:\n            return False\n    \n    def _get_activities(self):\n        \"\"\"Get list of activities\"\"\"\n        try:\n            activities = []\n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for activity in manifest.iter('activity'):\n                name = activity.get('{http://schemas.android.com/apk/res/android}name')\n                if name:\n                    activities.append(name)\n            \n            return activities\n        except:\n            return []\n    \n    def _get_services(self):\n        \"\"\"Get list of services\"\"\"\n        try:\n            services = []\n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for service in manifest.iter('service'):\n                name = service.get('{http://schemas.android.com/apk/res/android}name')\n                if name:\n                    services.append(name)\n            \n            return services\n        except:\n            return []\n    \n    def _get_receivers(self):\n        \"\"\"Get list of broadcast receivers\"\"\"\n        try:\n            receivers = []\n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for receiver in manifest.iter('receiver'):\n                name = receiver.get('{http://schemas.android.com/apk/res/android}name')\n                if name:\n                    receivers.append(name)\n            \n            return receivers\n        except:\n            return []\n    \n    def _get_providers(self):\n        \"\"\"Get list of content providers\"\"\"\n        try:\n            providers = []\n            manifest = self.apk_obj.get_android_manifest_xml()\n            \n            for provider in manifest.iter('provider'):\n                name = provider.get('{http://schemas.android.com/apk/res/android}name')\n                if name:\n                    providers.append(name)\n            \n            return providers\n        except:\n            return []\n    \n    def _get_app_icon(self):\n        \"\"\"Extract app icon\"\"\"\n        try:\n            # Method 1: Use androguard's built-in method\n            try:\n                icon_data = self.apk_obj.get_app_icon()\n                if icon_data and len(icon_data) > 100:  # Ensure it's a proper image file, not just metadata\n                    # Convert string to bytes if needed\n                    if isinstance(icon_data, str):\n                        icon_data = icon_data.encode('latin-1')\n                    return icon_data\n                else:\n                    print(f\"Built-in icon too small: {len(icon_data) if icon_data else 0} bytes\")\n            except Exception as e:\n                print(f\"Built-in icon method failed: {e}\")\n            \n            # Method 2: Extract from resources.arsc and find icon files\n            try:\n                # Get the icon resource ID from manifest\n                manifest = self.apk_obj.get_android_manifest_xml()\n                app_element = manifest.find('application')\n                if app_element is not None:\n                    icon_attr = app_element.get('{http://schemas.android.com/apk/res/android}icon')\n                    if icon_attr:\n                        # Try to find the actual icon file\n                        with zipfile.ZipFile(self.apk_path, 'r') as z:\n                            # Look for common icon paths\n                            icon_paths = [\n                                'res/drawable/ic_launcher.png',\n                                'res/drawable-hdpi/ic_launcher.png',\n                                'res/drawable-mdpi/ic_launcher.png',\n                                'res/drawable-xhdpi/ic_launcher.png',\n                                'res/drawable-xxhdpi/ic_launcher.png',\n                                'res/drawable-xxxhdpi/ic_launcher.png',\n                                'res/mipmap/ic_launcher.png',\n                                'res/mipmap-hdpi/ic_launcher.png',\n                                'res/mipmap-mdpi/ic_launcher.png',\n                                'res/mipmap-xhdpi/ic_launcher.png',\n                                'res/mipmap-xxhdpi/ic_launcher.png',\n                                'res/mipmap-xxxhdpi/ic_launcher.png',\n                            ]\n                            \n                            # Try each icon path\n                            for icon_path in icon_paths:\n                                try:\n                                    icon_data = z.read(icon_path)\n                                    if icon_data and len(icon_data) > 0:\n                                        return icon_data\n                                except KeyError:\n                                    continue\n                            \n                            # If specific paths don't work, search for any ic_launcher files\n                            for file_path in z.namelist():\n                                if 'ic_launcher' in file_path and file_path.endswith(('.png', '.jpg', '.jpeg')):\n                                    try:\n                                        icon_data = z.read(file_path)\n                                        if icon_data and len(icon_data) > 0:\n                                            return icon_data\n                                    except:\n                                        continue\n            except Exception as e:\n                print(f\"Resource-based icon extraction failed: {e}\")\n            \n            # Method 3: Search for any application icon in common directories\n            try:\n                with zipfile.ZipFile(self.apk_path, 'r') as z:\n                    # First priority: look for larger icon files\n                    icon_candidates = []\n                    \n                    for file_path in z.namelist():\n                        if (('icon' in file_path.lower() or 'launcher' in file_path.lower()) and \n                            file_path.endswith(('.png', '.jpg', '.jpeg')) and\n                            'res/' in file_path):\n                            try:\n                                icon_data = z.read(file_path)\n                                if icon_data and len(icon_data) > 100:  # Only consider files larger than 100 bytes\n                                    icon_candidates.append((file_path, icon_data, len(icon_data)))\n                                    print(f\"Found icon candidate: {file_path} ({len(icon_data)} bytes)\")\n                            except:\n                                continue\n                    \n                    # Sort by file size (largest first) and return the biggest icon\n                    if icon_candidates:\n                        icon_candidates.sort(key=lambda x: x[2], reverse=True)\n                        best_icon = icon_candidates[0]\n                        print(f\"Selected best icon: {best_icon[0]} ({best_icon[2]} bytes)\")\n                        return best_icon[1]\n            except Exception as e:\n                print(f\"General icon search failed: {e}\")\n            \n            # Method 2: Manual extraction from common icon locations\n            try:\n                with zipfile.ZipFile(self.apk_path, 'r') as z:\n                    # Common icon paths in order of preference (highest density first)\n                    icon_paths = [\n                        'res/mipmap-xxxhdpi/ic_launcher.png',\n                        'res/mipmap-xxhdpi/ic_launcher.png', \n                        'res/mipmap-xhdpi/ic_launcher.png',\n                        'res/mipmap-hdpi/ic_launcher.png',\n                        'res/mipmap-mdpi/ic_launcher.png',\n                        'res/mipmap-ldpi/ic_launcher.png',\n                        'res/drawable-xxxhdpi/ic_launcher.png',\n                        'res/drawable-xxhdpi/ic_launcher.png',\n                        'res/drawable-xhdpi/ic_launcher.png',\n                        'res/drawable-hdpi/ic_launcher.png',\n                        'res/drawable-mdpi/ic_launcher.png',\n                        'res/drawable-ldpi/ic_launcher.png'\n                    ]\n                    \n                    # Try each common path\n                    for icon_path in icon_paths:\n                        if icon_path in z.namelist():\n                            return z.read(icon_path)\n                    \n                    # Search for any launcher icon file\n                    for file in z.namelist():\n                        if ('ic_launcher' in file or 'launcher' in file) and file.endswith(('.png', '.jpg', '.jpeg', '.webp')):\n                            return z.read(file)\n                    \n                    # Fallback: search for any icon file\n                    for file in z.namelist():\n                        if 'icon' in file.lower() and file.endswith(('.png', '.jpg', '.jpeg', '.webp')):\n                            return z.read(file)\n            except:\n                pass\n                \n            return None\n        except:\n            return None\n    \n    def _get_manifest_xml(self):\n        \"\"\"Get formatted Android Manifest XML\"\"\"\n        try:\n            # Method 1: Try androguard's direct XML conversion\n            try:\n                manifest_xml = self.apk_obj.get_android_manifest_xml()\n                if manifest_xml is not None:\n                    import xml.etree.ElementTree as ET\n                    \n                    # Add proper indentation for readability\n                    def indent(elem, level=0):\n                        i = \"\\n\" + level*\"  \"\n                        if len(elem):\n                            if not elem.text or not elem.text.strip():\n                                elem.text = i + \"  \"\n                            if not elem.tail or not elem.tail.strip():\n                                elem.tail = i\n                            for child in elem:\n                                indent(child, level+1)\n                            if not elem.tail or not elem.tail.strip():\n                                elem.tail = i\n                        else:\n                            if level and (not elem.tail or not elem.tail.strip()):\n                                elem.tail = i\n                    \n                    # Handle both cases: root element or tree object\n                    if hasattr(manifest_xml, 'getroot'):\n                        root = manifest_xml.getroot()\n                    else:\n                        root = manifest_xml\n                    \n                    indent(root)\n                    xml_string = ET.tostring(root, encoding='unicode', method='xml')\n                    \n                    # Add XML declaration\n                    if not xml_string.startswith('<?xml'):\n                        xml_string = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' + xml_string\n                    \n                    return xml_string\n            except Exception as e1:\n                print(f\"Method 1 failed: {e1}\")\n                pass\n            \n            # Method 2: Use androguard's get_xml() method\n            try:\n                manifest_data = self.apk_obj.get_android_manifest_axml()\n                if manifest_data:\n                    xml_content = manifest_data.get_xml()\n                    if xml_content:\n                        return xml_content\n            except Exception as e2:\n                print(f\"Method 2 failed: {e2}\")\n                pass\n            \n            # Method 3: Direct AXML parsing\n            try:\n                from androguard.core.axml import AXML\n                with zipfile.ZipFile(self.apk_path, 'r') as z:\n                    if 'AndroidManifest.xml' in z.namelist():\n                        manifest_bytes = z.read('AndroidManifest.xml')\n                        axml = AXML(manifest_bytes)\n                        xml_content = axml.get_xml()\n                        if xml_content:\n                            return xml_content\n            except Exception as e3:\n                print(f\"Method 3 failed: {e3}\")\n                pass\n            \n            # Method 4: Try alternative androguard methods\n            try:\n                # Sometimes the XML needs to be accessed differently\n                manifest_content = str(self.apk_obj.get_android_manifest_xml())\n                if manifest_content and manifest_content != 'None':\n                    return manifest_content\n            except Exception as e4:\n                print(f\"Method 4 failed: {e4}\")\n                pass\n                \n            return \"AndroidManifest.xml found but parsing failed. The file is in binary AXML format.\"\n            \n        except Exception as e:\n            print(f\"Manifest XML extraction error: {e}\")\n            return None\n","size_bytes":32652},"app.py":{"content":"import streamlit as st\nimport os\nimport tempfile\nfrom pathlib import Path\nimport pandas as pd\nfrom apk_analyzer import APKAnalyzer\nfrom comparison_utils import APKComparator\nfrom utils import format_size, safe_get\n\ndef check_security_concerns(data):\n    \"\"\"Check for security concerns and return warnings\"\"\"\n    concerns = []\n    \n    # Check for dangerous permissions\n    permissions = safe_get(data, 'permissions', {}).get('declared', [])\n    dangerous_perms = []\n    for perm in permissions:\n        if 'INTERNET' in perm.upper():\n            dangerous_perms.append('Internet Access')\n        elif any(x in perm.upper() for x in ['WRITE_EXTERNAL_STORAGE', 'READ_EXTERNAL_STORAGE', 'MANAGE_EXTERNAL_STORAGE']):\n            dangerous_perms.append('Folder Access')\n    \n    if dangerous_perms:\n        concerns.append(f\"⚠️ **Risky Permissions**: {', '.join(dangerous_perms)}\")\n    \n    # Check OpenGL version\n    features = safe_get(data, 'features', {})\n    opengl_version = features.get('opengl_version', '')\n    if opengl_version and '2.0' not in opengl_version:\n        concerns.append(f\"⚠️ **OpenGL Version**: {opengl_version} (expected 2.0)\")\n    \n    # Check Architecture\n    architecture = safe_get(data, 'architectures', '')\n    if architecture and 'armeabi-v7a' not in architecture:\n        concerns.append(f\"⚠️ **Architecture**: {architecture} (expected armeabi-v7a)\")\n    \n    # Check Target SDK\n    target_sdk = safe_get(data, 'target_sdk_version', '')\n    if target_sdk and str(target_sdk) != '29':\n        concerns.append(f\"⚠️ **Target SDK**: API {target_sdk} (expected API 29)\")\n    \n    # Check Unity Export Status\n    unity_exported = safe_get(data, 'unity_exported', None)\n    if unity_exported is not None and not unity_exported:\n        concerns.append(\"⚠️ **Unity Export**: Main activity missing android:exported='true'\")\n    \n    # Check Signature\n    signature = safe_get(data, 'signature', {})\n    if signature:\n        valid_from = safe_get(signature, 'valid_from', '')\n        signer = safe_get(signature, 'signer', '')\n        sha256_digest = safe_get(signature, 'sha256_digest', '')\n        \n        expected_date = '2020-12-10 13:55:47 UTC'\n        expected_signer = 'Avik Bhowmik'\n        expected_sha256 = '9C:EC:B0:0D:53:B2:FA:05:0A:9E:91:96:3D:4F:A1:5F:53:9C:D9:8F:F1:B5:FF:E4:17:60:01:FD:7E:60:A0:7A'\n        \n        signature_issues = []\n        if expected_date not in valid_from:\n            signature_issues.append(f\"date mismatch (found: {valid_from})\")\n        \n        if expected_signer not in signer:\n            signature_issues.append(f\"signer mismatch (found: {signer})\")\n        \n        # SHA-256 fingerprint verification\n        if sha256_digest != 'Unknown' and sha256_digest != expected_sha256:\n            signature_issues.append(\"SHA-256 mismatch\")\n        \n        if signature_issues:\n            concerns.append(f\"⚠️ **Signature Issue**: {' and '.join(signature_issues)}\")\n    \n    return concerns\n\n# Configure page\nst.set_page_config(\n    page_title=\"APK Analysis Tool\",\n    page_icon=\"📱\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\ndef main():\n    st.title(\"📱 APK Analysis Tool\")\n    st.markdown(\"Upload APK files to extract metadata, permissions, features, and signature details\")\n    \n    # Sidebar for mode selection\n    with st.sidebar:\n        st.header(\"Analysis Mode\")\n        mode = st.radio(\n            \"Choose analysis mode:\",\n            [\"Single APK Analysis\", \"Batch APK Analysis\", \"Dual APK Comparison\"],\n            help=\"Single mode analyzes one APK, Batch mode analyzes multiple APKs, Comparison mode compares two APKs\"\n        )\n        \n        st.markdown(\"---\")\n        st.markdown(\"Upload APK files to get detailed analysis including permissions, features, signature verification, and security insights.\")\n    \n    if mode == \"Single APK Analysis\":\n        single_apk_analysis()\n    elif mode == \"Batch APK Analysis\":\n        batch_apk_analysis()\n    else:\n        dual_apk_comparison()\n\ndef single_apk_analysis():\n    st.header(\"Single APK Analysis\")\n    \n    # Add file size information\n    st.info(\"📋 **File Size Limit:** 500 MB per APK file. If you encounter upload errors, try smaller APK files.\")\n    \n    uploaded_file = st.file_uploader(\n        \"Upload APK file\",\n        type=['apk'],\n        help=\"Select an Android APK file for analysis (max 500 MB)\"\n    )\n    \n    if uploaded_file is not None:\n        file_size = len(uploaded_file.getvalue())\n        st.write(f\"📊 **File size:** {format_size(file_size)}\")\n        with st.spinner(\"Analyzing APK...\"):\n            try:\n                # Save uploaded file temporarily\n                with tempfile.NamedTemporaryFile(delete=False, suffix='.apk') as tmp_file:\n                    tmp_file.write(uploaded_file.getvalue())\n                    tmp_file_path = tmp_file.name\n                \n                # Analyze APK\n                analyzer = APKAnalyzer(tmp_file_path)\n                analysis_data = analyzer.analyze()\n                \n                # Display results\n                display_apk_analysis(analysis_data, uploaded_file.name)\n                \n                # Cleanup\n                os.unlink(tmp_file_path)\n                \n            except Exception as e:\n                st.error(f\"Error analyzing APK: {str(e)}\")\n                st.exception(e)\n\ndef batch_apk_analysis():\n    st.header(\"Batch APK Analysis\")\n    st.markdown(\"Upload multiple APK files to analyze them in batch and get a comprehensive overview\")\n    \n    # Add file size information\n    st.info(\"📋 **File Size Limit:** 500 MB per APK file. If you encounter upload errors, try smaller APK files.\")\n    \n    # Use session state to manage file uploads and avoid pagination issues\n    if 'batch_files' not in st.session_state:\n        st.session_state.batch_files = []\n    \n    # File uploader with session state management\n    uploaded_files = st.file_uploader(\n        \"Upload APK files\",\n        type=['apk'],\n        accept_multiple_files=True,\n        help=\"Select multiple Android APK files for batch analysis (max 500 MB each)\",\n        key=\"batch_uploader\"\n    )\n    \n    # Update session state if new files are uploaded\n    if uploaded_files:\n        st.session_state.batch_files = uploaded_files\n    \n    # Display all uploaded files in a custom list to avoid pagination\n    if st.session_state.batch_files:\n        st.markdown(\"### 📁 Uploaded Files\")\n        \n        # Custom file list display\n        for i, file in enumerate(st.session_state.batch_files):\n            col1, col2, col3 = st.columns([3, 1, 1])\n            with col1:\n                st.write(f\"📄 {file.name}\")\n            with col2:\n                st.write(f\"{file.size / (1024*1024):.1f} MB\")\n            with col3:\n                if st.button(\"❌\", key=f\"remove_{i}\", help=\"Remove file\"):\n                    # Remove file from list\n                    st.session_state.batch_files = [f for j, f in enumerate(st.session_state.batch_files) if j != i]\n                    st.rerun()\n        \n        # Clear all files button\n        if st.button(\"🗑️ Clear All Files\"):\n            st.session_state.batch_files = []\n            st.rerun()\n        \n        # Use the files from session state for analysis\n        files_to_analyze = st.session_state.batch_files\n        \n        st.info(f\"📁 {len(files_to_analyze)} APK files ready for analysis\")\n        \n        # Analysis options\n        col1, col2 = st.columns(2)\n        with col1:\n            show_details = st.checkbox(\"Show detailed analysis for each APK\", value=False)\n        with col2:\n            export_csv = st.checkbox(\"Enable CSV export\", value=True)\n        \n        if st.button(\"🚀 Analyze All APKs\", type=\"primary\"):\n            analyze_batch_apks(files_to_analyze, show_details, export_csv)\n\ndef analyze_batch_apks(uploaded_files, show_details, export_csv):\n    \"\"\"Analyze multiple APK files in batch\"\"\"\n    results = []\n    \n    # Progress tracking\n    progress_bar = st.progress(0)\n    status_text = st.empty()\n    \n    for i, uploaded_file in enumerate(uploaded_files):\n        status_text.text(f\"Analyzing {uploaded_file.name}...\")\n        progress_bar.progress((i + 1) / len(uploaded_files))\n        \n        try:\n            # Save uploaded file temporarily\n            with tempfile.NamedTemporaryFile(delete=False, suffix='.apk') as tmp_file:\n                tmp_file.write(uploaded_file.getvalue())\n                tmp_file_path = tmp_file.name\n            \n            # Analyze APK\n            analyzer = APKAnalyzer(tmp_file_path)\n            analysis_data = analyzer.analyze()\n            \n            # Add filename to analysis data\n            analysis_data['filename'] = uploaded_file.name\n            analysis_data['file_size_mb'] = uploaded_file.size / (1024 * 1024)\n            \n            results.append(analysis_data)\n            \n            # Cleanup\n            os.unlink(tmp_file_path)\n            \n        except Exception as e:\n            st.error(f\"Error analyzing {uploaded_file.name}: {str(e)}\")\n            results.append({\n                'filename': uploaded_file.name,\n                'error': str(e)\n            })\n    \n    status_text.text(\"Analysis complete!\")\n    progress_bar.progress(1.0)\n    \n    # Display results\n    display_batch_results(results, show_details, export_csv)\n\ndef display_batch_results(results, show_details, export_csv):\n    \"\"\"Display batch analysis results\"\"\"\n    st.success(f\"✅ Analyzed {len(results)} APK files\")\n    \n    # Summary statistics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    successful_analyses = [r for r in results if 'error' not in r]\n    with col1:\n        st.metric(\"Successful Analyses\", len(successful_analyses))\n    \n    with col2:\n        if successful_analyses:\n            total_size = sum(r.get('file_size', 0) for r in successful_analyses)\n            st.metric(\"Total Size\", f\"{format_size(total_size)}\")\n        else:\n            st.metric(\"Total Size\", \"0 MB\")\n    \n    with col3:\n        total_concerns = sum(len(check_security_concerns(r)) for r in successful_analyses)\n        st.metric(\"Total Concerns\", total_concerns)\n    \n    with col4:\n        unique_packages = len(set(r.get('package_name', '') for r in successful_analyses if r.get('package_name')))\n        st.metric(\"Unique Packages\", unique_packages)\n    \n    # Summary table\n    st.subheader(\"📊 Analysis Summary\")\n    if successful_analyses:\n        summary_data = []\n        for result in successful_analyses:\n            concerns = check_security_concerns(result)\n            summary_data.append({\n                'Filename': result.get('filename', 'Unknown'),\n                'App Name': safe_get(result, 'app_name', 'Unknown'),\n                'Package': safe_get(result, 'package_name', 'Unknown'),\n                'Version': safe_get(result, 'version_name', 'Unknown'),\n                'Size': format_size(safe_get(result, 'file_size', 0)),\n                'Concerns': len(concerns),\n                'Architecture': safe_get(result, 'architectures', 'Unknown'),\n                'Min SDK': safe_get(result, 'min_sdk_version', 'Unknown'),\n                'Target SDK': safe_get(result, 'target_sdk_version', 'Unknown')\n            })\n        \n        df = pd.DataFrame(summary_data)\n        st.dataframe(df, use_container_width=True)\n        \n        # CSV export\n        if export_csv:\n            csv = df.to_csv(index=False)\n            st.download_button(\n                label=\"📥 Download Summary as CSV\",\n                data=csv,\n                file_name=\"apk_batch_analysis.csv\",\n                mime=\"text/csv\",\n                key=\"batch_csv_download\"\n            )\n    \n    # Detailed analysis for each APK\n    if show_details and successful_analyses:\n        st.markdown(\"---\")\n        st.subheader(\"📱 Detailed Analysis\")\n        \n        for i, result in enumerate(successful_analyses):\n            with st.expander(f\"{result.get('filename', 'Unknown')} - Detailed Analysis\", expanded=False):\n                # Create a unique context for each detailed analysis to avoid ID conflicts\n                st.markdown(f\"### {result.get('filename', 'Unknown')}\")\n                display_apk_analysis_batch(result, result.get('filename', 'Unknown'), i)\n\ndef display_apk_analysis_batch(data, filename, index):\n    \"\"\"Display APK analysis for batch mode with unique keys\"\"\"\n    # Security Concerns Check\n    security_concerns = check_security_concerns(data)\n    if security_concerns:\n        st.error(\"🚨 **Concerns Detected**\")\n        for concern in security_concerns:\n            st.warning(concern)\n        st.markdown(\"---\")\n    \n    # App Overview with Icon\n    with st.expander(\"📱 App Overview\", expanded=True):\n        # Display app icon if available\n        app_icon = safe_get(data, 'app_icon', None)\n        if app_icon:\n            try:\n                from io import BytesIO\n                col_icon, col_info = st.columns([1, 4])\n                with col_icon:\n                    # Convert to bytes if needed, then to BytesIO for Streamlit\n                    if isinstance(app_icon, str):\n                        # Convert string to bytes using latin-1 encoding\n                        icon_bytes = app_icon.encode('latin-1')\n                        icon_stream = BytesIO(icon_bytes)\n                        st.image(icon_stream, width=100, caption=\"App Icon\")\n                    elif isinstance(app_icon, bytes):\n                        icon_stream = BytesIO(app_icon)\n                        st.image(icon_stream, width=100, caption=\"App Icon\")\n                    else:\n                        st.image(app_icon, width=100, caption=\"App Icon\")\n                with col_info:\n                    st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n                    st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n                    st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')}\")\n                    st.write(f\"**Build:** {safe_get(data, 'version_code', 'Unknown')}\")\n            except Exception as e:\n                # If icon display fails, show debug info and continue without icon\n                st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n                st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n                st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')}\")\n                st.write(f\"**Build:** {safe_get(data, 'version_code', 'Unknown')}\")\n                st.info(f\"📱 Icon available but couldn't display: {type(app_icon)} - {len(app_icon) if hasattr(app_icon, '__len__') else 'N/A'} bytes\")\n        else:\n            st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n            st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n            st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')}\")\n            st.write(f\"**Build:** {safe_get(data, 'version_code', 'Unknown')}\")\n            st.info(\"📱 No app icon found\")\n        \n        st.write(f\"**Min OS:** API {safe_get(data, 'min_sdk_version', 'Unknown')}\")\n        st.write(f\"**Target OS:** API {safe_get(data, 'target_sdk_version', 'Unknown')}\")\n        st.write(f\"**Size:** {format_size(safe_get(data, 'file_size', 0))}\")\n        st.write(f\"**Architecture:** {safe_get(data, 'architectures', 'Unknown')}\")\n        st.write(f\"**Debuggable:** {'Yes' if safe_get(data, 'debuggable', False) else 'No'}\")\n        \n        # OpenGL Version in overview\n        features = safe_get(data, 'features', {})\n        opengl_version = features.get('opengl_version')\n        if opengl_version:\n            st.write(f\"**Graphics:** {opengl_version}\")\n    \n    # Permissions\n    with st.expander(\"🔒 Permissions\", expanded=False):\n        permissions = safe_get(data, 'permissions', {})\n        \n        st.subheader(\"Declared Permissions\")\n        declared = permissions.get('declared', [])\n        if declared:\n            for perm in declared:\n                st.write(f\"• {perm}\")\n        else:\n            st.info(\"No declared permissions found\")\n    \n    # Signature Details\n    with st.expander(\"🔐 Signature Details\", expanded=False):\n        signature = safe_get(data, 'signature', {})\n        \n        if signature:\n            st.subheader(\"SIGNATURE\")\n            \n            # Basic signature information in a clean format\n            signer_info = safe_get(signature, 'signer', 'Unknown')\n            st.write(f\"**Signer:** {signer_info}\")\n            st.write(f\"**Valid from:** {safe_get(signature, 'valid_from', 'Unknown')}\")\n            st.write(f\"**Valid until:** {safe_get(signature, 'valid_until', 'Unknown')}\")\n            st.write(f\"**Algorithm:** {safe_get(signature, 'algorithm', 'Unknown')}\")\n            \n            st.write(\"---\")\n            st.subheader(\"Certificate Fingerprints\")\n            \n            # Display certificate fingerprints in a more readable format\n            sha256_digest = safe_get(signature, 'sha256_digest', 'Unknown')\n            sha1_digest = safe_get(signature, 'sha1_digest', 'Unknown')\n            md5_digest = safe_get(signature, 'md5_digest', 'Unknown')\n            \n            if sha256_digest != 'Unknown':\n                st.write(\"**SHA-256:**\")\n                st.code(sha256_digest, language=None)\n            else:\n                st.write(f\"**SHA-256:** {sha256_digest}\")\n                \n            if sha1_digest != 'Unknown':\n                st.write(\"**SHA-1:**\")\n                st.code(sha1_digest, language=None)\n            else:\n                st.write(f\"**SHA-1:** {sha1_digest}\")\n                \n            if md5_digest != 'Unknown':\n                st.write(\"**MD5:**\")\n                st.code(md5_digest, language=None)\n            else:\n                st.write(f\"**MD5:** {md5_digest}\")\n            \n            st.write(\"---\")\n            st.subheader(\"Verification Schemes\")\n            \n            # Display verification schemes in a cleaner format\n            schemes = signature.get('schemes', {})\n            for scheme_name, status in schemes.items():\n                status_icon = \"✅\" if status else \"❌\"\n                status_text = \"Verified\" if status else \"Not verified\"\n                st.write(f\"{status_icon} **{scheme_name}:** {status_text}\")\n        else:\n            st.warning(\"No signature information found\")\n    \n    # Android Manifest\n    with st.expander(\"📄 Android Manifest XML\", expanded=False):\n        manifest_xml = safe_get(data, 'manifest_xml', None)\n        if manifest_xml:\n            # Create tabs for different viewing options\n            tab1, tab2 = st.tabs([\"📋 Formatted View\", \"💻 Raw XML\"])\n            \n            with tab1:\n                # Pretty formatted version with better readability\n                try:\n                    import xml.dom.minidom\n                    # Parse and pretty print the XML\n                    dom = xml.dom.minidom.parseString(manifest_xml)\n                    pretty_xml = dom.toprettyxml(indent=\"  \")\n                    # Remove empty lines\n                    pretty_lines = [line for line in pretty_xml.split('\\n') if line.strip()]\n                    pretty_xml = '\\n'.join(pretty_lines)\n                    \n                    st.code(pretty_xml, language='xml', line_numbers=True)\n                except:\n                    # Fallback to original if pretty printing fails\n                    st.code(manifest_xml, language='xml', line_numbers=True)\n            \n            with tab2:\n                # Raw XML in a scrollable text area\n                st.text_area(\n                    \"Raw AndroidManifest.xml\", \n                    value=manifest_xml, \n                    height=500, \n                    label_visibility=\"collapsed\",\n                    help=\"Raw XML content with vertical scrolling\",\n                    key=f\"manifest_raw_{index}\"\n                )\n                \n            # Add download button with unique key\n            st.download_button(\n                label=\"📥 Download AndroidManifest.xml\",\n                data=manifest_xml,\n                file_name=f\"{safe_get(data, 'package_name', 'unknown')}_AndroidManifest.xml\",\n                mime=\"application/xml\",\n                key=f\"manifest_download_batch_{index}\"\n            )\n        else:\n            st.warning(\"Android Manifest XML not available\")\n\ndef dual_apk_comparison():\n    st.header(\"Dual APK Comparison\")\n    \n    # Add file size information\n    st.info(\"📋 **File Size Limit:** 500 MB per APK file. If you encounter upload errors, try smaller APK files.\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"First APK\")\n        uploaded_file1 = st.file_uploader(\n            \"Upload first APK file\",\n            type=['apk'],\n            key=\"apk1\",\n            help=\"Select the first Android APK file for comparison (max 500 MB)\"\n        )\n        if uploaded_file1 is not None:\n            file_size1 = len(uploaded_file1.getvalue())\n            st.write(f\"📊 **File size:** {format_size(file_size1)}\")\n    \n    with col2:\n        st.subheader(\"Second APK\")\n        uploaded_file2 = st.file_uploader(\n            \"Upload second APK file\",\n            type=['apk'],\n            key=\"apk2\",\n            help=\"Select the second Android APK file for comparison (max 500 MB)\"\n        )\n        if uploaded_file2 is not None:\n            file_size2 = len(uploaded_file2.getvalue())\n            st.write(f\"📊 **File size:** {format_size(file_size2)}\")\n    \n    if uploaded_file1 is not None and uploaded_file2 is not None:\n        with st.spinner(\"Analyzing and comparing APKs...\"):\n            try:\n                # Save uploaded files temporarily\n                with tempfile.NamedTemporaryFile(delete=False, suffix='.apk') as tmp_file1:\n                    tmp_file1.write(uploaded_file1.getvalue())\n                    tmp_file1_path = tmp_file1.name\n                \n                with tempfile.NamedTemporaryFile(delete=False, suffix='.apk') as tmp_file2:\n                    tmp_file2.write(uploaded_file2.getvalue())\n                    tmp_file2_path = tmp_file2.name\n                \n                # Analyze both APKs\n                analyzer1 = APKAnalyzer(tmp_file1_path)\n                analyzer2 = APKAnalyzer(tmp_file2_path)\n                \n                analysis1 = analyzer1.analyze()\n                analysis2 = analyzer2.analyze()\n                \n                # Compare APKs\n                comparator = APKComparator(analysis1, analysis2)\n                comparison_data = comparator.compare()\n                \n                # Display comparison\n                display_apk_comparison(analysis1, analysis2, comparison_data, \n                                     uploaded_file1.name, uploaded_file2.name)\n                \n                # Cleanup\n                os.unlink(tmp_file1_path)\n                os.unlink(tmp_file2_path)\n                \n            except Exception as e:\n                st.error(f\"Error comparing APKs: {str(e)}\")\n                st.exception(e)\n\ndef display_apk_analysis(data, filename):\n    st.success(f\"✅ Successfully analyzed: {filename}\")\n    \n    # Security Concerns Check\n    security_concerns = check_security_concerns(data)\n    if security_concerns:\n        st.error(\"🚨 **Concerns Detected**\")\n        for concern in security_concerns:\n            st.warning(concern)\n        st.markdown(\"---\")\n    \n    # App Overview with Icon\n    with st.expander(\"📱 App Overview\", expanded=True):\n        # Display app icon if available\n        app_icon = safe_get(data, 'app_icon', None)\n        if app_icon:\n            try:\n                from io import BytesIO\n                col_icon, col_info = st.columns([1, 4])\n                with col_icon:\n                    # Convert to bytes if needed, then to BytesIO for Streamlit\n                    if isinstance(app_icon, str):\n                        # Convert string to bytes using latin-1 encoding\n                        icon_bytes = app_icon.encode('latin-1')\n                        icon_stream = BytesIO(icon_bytes)\n                        st.image(icon_stream, width=100, caption=\"App Icon\")\n                    elif isinstance(app_icon, bytes):\n                        icon_stream = BytesIO(app_icon)\n                        st.image(icon_stream, width=100, caption=\"App Icon\")\n                    else:\n                        st.image(app_icon, width=100, caption=\"App Icon\")\n                with col_info:\n                    st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n                    st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n                    st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')}\")\n                    st.write(f\"**Build:** {safe_get(data, 'version_code', 'Unknown')}\")\n            except Exception as e:\n                # If icon display fails, show debug info and continue without icon\n                st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n                st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n                st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')}\")\n                st.write(f\"**Build:** {safe_get(data, 'version_code', 'Unknown')}\")\n                st.info(f\"📱 Icon available but couldn't display: {type(app_icon)} - {len(app_icon) if hasattr(app_icon, '__len__') else 'N/A'} bytes\")\n        else:\n            st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n            st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n            st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')}\")\n            st.write(f\"**Build:** {safe_get(data, 'version_code', 'Unknown')}\")\n            st.info(\"📱 No app icon found\")\n        \n        st.write(f\"**Min OS:** API {safe_get(data, 'min_sdk_version', 'Unknown')}\")\n        st.write(f\"**Target OS:** API {safe_get(data, 'target_sdk_version', 'Unknown')}\")\n        st.write(f\"**Size:** {format_size(safe_get(data, 'file_size', 0))}\")\n        st.write(f\"**Architecture:** {safe_get(data, 'architectures', 'Unknown')}\")\n        st.write(f\"**Debuggable:** {'Yes' if safe_get(data, 'debuggable', False) else 'No'}\")\n        \n        # OpenGL Version in overview\n        features = safe_get(data, 'features', {})\n        opengl_version = features.get('opengl_version')\n        if opengl_version:\n            st.write(f\"**Graphics:** {opengl_version}\")\n    \n    # Permissions\n    with st.expander(\"🔒 Permissions\", expanded=False):\n        permissions = safe_get(data, 'permissions', {})\n        \n        st.subheader(\"Declared Permissions\")\n        declared = permissions.get('declared', [])\n        if declared:\n            for perm in declared:\n                st.write(f\"• {perm}\")\n        else:\n            st.info(\"No declared permissions found\")\n        \n        st.subheader(\"Implied Permissions\")\n        implied = permissions.get('implied', [])\n        if implied:\n            for perm in implied:\n                st.write(f\"• {perm}\")\n        else:\n            st.info(\"No implied permissions found\")\n        \n        st.subheader(\"Optional Permissions\")\n        optional = permissions.get('optional', [])\n        if optional:\n            for perm in optional:\n                st.write(f\"• {perm}\")\n        else:\n            st.info(\"No optional permissions found\")\n    \n    # Features\n    with st.expander(\"⚡ Features\", expanded=False):\n        features = safe_get(data, 'features', {})\n        \n        st.subheader(\"Required Features\")\n        required = features.get('required', [])\n        if required:\n            for feat in required:\n                st.write(f\"• {feat}\")\n        else:\n            st.info(\"No required features found\")\n        \n        st.subheader(\"Implied Features\")\n        implied = features.get('implied', [])\n        if implied:\n            for feat in implied:\n                st.write(f\"• {feat}\")\n        else:\n            st.info(\"No implied features found\")\n        \n        st.subheader(\"Not Required Features\")\n        not_required = features.get('not_required', [])\n        if not_required:\n            for feat in not_required:\n                st.write(f\"• {feat}\")\n        else:\n            st.info(\"No not-required features found\")\n    \n    # Signature Details\n    with st.expander(\"🔐 Signature Details\", expanded=False):\n        signature = safe_get(data, 'signature', {})\n        \n        if signature:\n            st.subheader(\"SIGNATURE\")\n            \n            # Basic signature information in a clean format\n            signer_info = safe_get(signature, 'signer', 'Unknown')\n            st.write(f\"**Signer:** {signer_info}\")\n            st.write(f\"**Valid from:** {safe_get(signature, 'valid_from', 'Unknown')}\")\n            st.write(f\"**Valid until:** {safe_get(signature, 'valid_until', 'Unknown')}\")\n            st.write(f\"**Algorithm:** {safe_get(signature, 'algorithm', 'Unknown')}\")\n            \n            st.write(\"---\")\n            st.subheader(\"Certificate Fingerprints\")\n            \n            # Display certificate fingerprints in a more readable format\n            sha256_digest = safe_get(signature, 'sha256_digest', 'Unknown')\n            sha1_digest = safe_get(signature, 'sha1_digest', 'Unknown')\n            md5_digest = safe_get(signature, 'md5_digest', 'Unknown')\n            \n            if sha256_digest != 'Unknown':\n                st.write(\"**SHA-256:**\")\n                st.code(sha256_digest, language=None)\n            else:\n                st.write(f\"**SHA-256:** {sha256_digest}\")\n                \n            if sha1_digest != 'Unknown':\n                st.write(\"**SHA-1:**\")\n                st.code(sha1_digest, language=None)\n            else:\n                st.write(f\"**SHA-1:** {sha1_digest}\")\n                \n            if md5_digest != 'Unknown':\n                st.write(\"**MD5:**\")\n                st.code(md5_digest, language=None)\n            else:\n                st.write(f\"**MD5:** {md5_digest}\")\n            \n            st.write(\"---\")\n            st.subheader(\"Verification Schemes\")\n            \n            # Display verification schemes in a cleaner format\n            schemes = signature.get('schemes', {})\n            for scheme_name, status in schemes.items():\n                status_icon = \"✅\" if status else \"❌\"\n                status_text = \"Verified\" if status else \"Not verified\"\n                st.write(f\"{status_icon} **{scheme_name}:** {status_text}\")\n        else:\n            st.warning(\"No signature information found\")\n    \n    # Unity Export Check\n    with st.expander(\"🎮 Unity Export Check\", expanded=False):\n        unity_exported = safe_get(data, 'unity_exported', None)\n        if unity_exported is not None:\n            if unity_exported:\n                st.info(\"ℹ️ Unity main activity has android:exported='true'\")\n            else:\n                st.success(\"✅ Unity main activity does not have android:exported='true'\")\n        else:\n            st.info(\"ℹ️ No Unity main activity found or unable to determine export status\")\n    \n    # Additional Details\n    with st.expander(\"📋 Additional Details\", expanded=False):\n        st.subheader(\"Screen Support\")\n        screens = safe_get(data, 'supported_screens', [])\n        if screens:\n            for screen in screens:\n                st.write(f\"• {screen}\")\n        else:\n            st.info(\"Screen support information not available\")\n        \n        st.subheader(\"Density Support\")\n        densities = safe_get(data, 'supported_densities', [])\n        if densities:\n            for density in densities:\n                st.write(f\"• {density}\")\n        else:\n            st.info(\"Density support information not available\")\n    \n    # Android Manifest\n    with st.expander(\"📄 Android Manifest XML\", expanded=False):\n        manifest_xml = safe_get(data, 'manifest_xml', None)\n        if manifest_xml:\n            # Create tabs for different viewing options\n            tab1, tab2 = st.tabs([\"📋 Formatted View\", \"💻 Raw XML\"])\n            \n            with tab1:\n                # Pretty formatted version with better readability\n                try:\n                    import xml.dom.minidom\n                    # Parse and pretty print the XML\n                    dom = xml.dom.minidom.parseString(manifest_xml)\n                    pretty_xml = dom.toprettyxml(indent=\"  \")\n                    # Remove empty lines\n                    pretty_lines = [line for line in pretty_xml.split('\\n') if line.strip()]\n                    pretty_xml = '\\n'.join(pretty_lines)\n                    \n                    st.code(pretty_xml, language='xml', line_numbers=True)\n                except:\n                    # Fallback to original if pretty printing fails\n                    st.code(manifest_xml, language='xml', line_numbers=True)\n            \n            with tab2:\n                # Raw XML in a scrollable text area\n                st.text_area(\n                    \"Raw AndroidManifest.xml\", \n                    value=manifest_xml, \n                    height=500, \n                    label_visibility=\"collapsed\",\n                    help=\"Raw XML content with vertical scrolling\"\n                )\n                \n            # Add download button\n            st.download_button(\n                label=\"📥 Download AndroidManifest.xml\",\n                data=manifest_xml,\n                file_name=\"AndroidManifest.xml\",\n                mime=\"application/xml\",\n                key=f\"manifest_download_{safe_get(data, 'package_name', 'unknown').replace('.', '_')}\"\n            )\n        else:\n            st.warning(\"Android Manifest XML not available\")\n\ndef display_apk_comparison(data1, data2, comparison, filename1, filename2):\n    st.success(f\"✅ Successfully compared: {filename1} vs {filename2}\")\n    \n    # Comparison Summary\n    with st.expander(\"📊 Comparison Summary\", expanded=True):\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.metric(\"Identical Permissions\", comparison.get('identical_permissions', 0))\n        with col2:\n            st.metric(\"Different Permissions\", comparison.get('different_permissions', 0))\n        with col3:\n            st.metric(\"Signature Match\", \"Yes\" if comparison.get('signature_match', False) else \"No\")\n    \n    # Side-by-side detailed comparison\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(f\"📱 {filename1}\")\n        display_apk_detailed_summary(data1)\n    \n    with col2:\n        st.subheader(f\"📱 {filename2}\")\n        display_apk_detailed_summary(data2)\n    \n    # Differences\n    with st.expander(\"🔍 Detailed Differences\", expanded=False):\n        differences = comparison.get('differences', {})\n        \n        if differences:\n            for category, diffs in differences.items():\n                if diffs:\n                    st.subheader(f\"{category.replace('_', ' ').title()}\")\n                    for diff in diffs:\n                        st.write(f\"• {diff}\")\n        else:\n            st.info(\"No significant differences found\")\n\ndef display_apk_summary(data):\n    st.write(f\"**App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n    st.write(f\"**Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n    st.write(f\"**Version:** {safe_get(data, 'version_name', 'Unknown')} ({safe_get(data, 'version_code', 'Unknown')})\")\n    st.write(f\"**Min SDK:** API {safe_get(data, 'min_sdk_version', 'Unknown')}\")\n    st.write(f\"**Target SDK:** API {safe_get(data, 'target_sdk_version', 'Unknown')}\")\n    st.write(f\"**Size:** {format_size(safe_get(data, 'file_size', 0))}\")\n    st.write(f\"**Debuggable:** {'Yes' if safe_get(data, 'debuggable', False) else 'No'}\")\n    \n    permissions = safe_get(data, 'permissions', {})\n    total_perms = len(permissions.get('declared', []))\n    st.write(f\"**Permissions:** {total_perms}\")\n    \n    features = safe_get(data, 'features', {})\n    total_features = len(features.get('required', []))\n    st.write(f\"**Features:** {total_features}\")\n\ndef display_apk_detailed_summary(data):\n    \"\"\"Display detailed APK summary for comparison mode\"\"\"\n    \n    # Security concerns check for comparison mode - with proper separation\n    security_concerns = check_security_concerns(data)\n    if security_concerns:\n        st.error(\"🚨 Security Concerns\")\n        for concern in security_concerns:\n            st.write(f\"• {concern}\")\n        st.write(\"---\")\n    \n    # App icon section\n    app_icon = safe_get(data, 'app_icon', None)\n    if app_icon:\n        try:\n            from io import BytesIO\n            if isinstance(app_icon, str):\n                icon_bytes = app_icon.encode('latin-1')\n                icon_stream = BytesIO(icon_bytes)\n            elif isinstance(app_icon, bytes):\n                icon_stream = BytesIO(app_icon)\n            else:\n                icon_stream = app_icon\n            st.image(icon_stream, width=60)\n        except Exception as e:\n            st.info(\"📱 Icon available\")\n    else:\n        st.info(\"📱 No icon\")\n    \n    # Basic Information section\n    st.write(\"**Basic Information**\")\n    st.write(f\"• **App Name:** {safe_get(data, 'app_name', 'Unknown')}\")\n    st.write(f\"• **Package:** {safe_get(data, 'package_name', 'Unknown')}\")\n    st.write(f\"• **Version:** {safe_get(data, 'version_name', 'Unknown')} ({safe_get(data, 'version_code', 'Unknown')})\")\n    st.write(f\"• **Min SDK:** API {safe_get(data, 'min_sdk_version', 'Unknown')}\")\n    st.write(f\"• **Target SDK:** API {safe_get(data, 'target_sdk_version', 'Unknown')}\")\n    st.write(f\"• **Size:** {format_size(safe_get(data, 'file_size', 0))}\")\n    st.write(f\"• **Architecture:** {safe_get(data, 'architectures', 'Unknown')}\")\n    st.write(f\"• **Debuggable:** {'Yes' if safe_get(data, 'debuggable', False) else 'No'}\")\n    \n    # Add graphics info if available\n    features = safe_get(data, 'features', {})\n    opengl_version = features.get('opengl_version')\n    if opengl_version:\n        st.write(f\"• **Graphics:** {opengl_version}\")\n    \n    # Permissions section\n    st.write(\"\")\n    st.write(\"**Permissions** (showing first 8)\")\n    permissions = safe_get(data, 'permissions', {})\n    declared = permissions.get('declared', [])\n    \n    if declared:\n        for perm in declared[:8]:  # Show first 8\n            clean_perm = perm.replace('android.permission.', '')\n            st.write(f\"• {clean_perm}\")\n        if len(declared) > 8:\n            st.write(f\"• ... and {len(declared) - 8} more\")\n    else:\n        st.write(\"• No permissions declared\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":38800},"comparison_utils.py":{"content":"class APKComparator:\n    def __init__(self, apk_data1, apk_data2):\n        self.apk1 = apk_data1\n        self.apk2 = apk_data2\n    \n    def compare(self):\n        \"\"\"Compare two APK analysis results\"\"\"\n        comparison_data = {\n            'identical_permissions': 0,\n            'different_permissions': 0,\n            'signature_match': False,\n            'differences': {\n                'basic_info': [],\n                'permissions': [],\n                'features': [],\n                'signature': [],\n                'components': []\n            }\n        }\n        \n        # Compare basic information\n        comparison_data['differences']['basic_info'] = self._compare_basic_info()\n        \n        # Compare permissions\n        perm_comparison = self._compare_permissions()\n        comparison_data['identical_permissions'] = perm_comparison['identical']\n        comparison_data['different_permissions'] = perm_comparison['different']\n        comparison_data['differences']['permissions'] = perm_comparison['differences']\n        \n        # Compare features\n        comparison_data['differences']['features'] = self._compare_features()\n        \n        # Compare signatures\n        sig_comparison = self._compare_signatures()\n        comparison_data['signature_match'] = sig_comparison['match']\n        comparison_data['differences']['signature'] = sig_comparison['differences']\n        \n        # Compare components\n        comparison_data['differences']['components'] = self._compare_components()\n        \n        return comparison_data\n    \n    def _compare_basic_info(self):\n        \"\"\"Compare basic app information\"\"\"\n        differences = []\n        \n        fields_to_compare = [\n            ('app_name', 'App Name'),\n            ('package_name', 'Package Name'),\n            ('version_name', 'Version Name'),\n            ('version_code', 'Version Code'),\n            ('min_sdk_version', 'Min SDK Version'),\n            ('target_sdk_version', 'Target SDK Version'),\n            ('debuggable', 'Debuggable'),\n            ('architectures', 'Architectures')\n        ]\n        \n        for field, display_name in fields_to_compare:\n            val1 = self.apk1.get(field, 'Unknown')\n            val2 = self.apk2.get(field, 'Unknown')\n            \n            if val1 != val2:\n                differences.append(f\"{display_name}: APK1='{val1}' vs APK2='{val2}'\")\n        \n        return differences\n    \n    def _compare_permissions(self):\n        \"\"\"Compare permissions between APKs\"\"\"\n        perms1 = set(self.apk1.get('permissions', {}).get('declared', []))\n        perms2 = set(self.apk2.get('permissions', {}).get('declared', []))\n        \n        identical = len(perms1.intersection(perms2))\n        only_in_1 = perms1 - perms2\n        only_in_2 = perms2 - perms1\n        different = len(only_in_1) + len(only_in_2)\n        \n        differences = []\n        \n        if only_in_1:\n            differences.append(f\"Only in APK1: {', '.join(sorted(only_in_1))}\")\n        \n        if only_in_2:\n            differences.append(f\"Only in APK2: {', '.join(sorted(only_in_2))}\")\n        \n        return {\n            'identical': identical,\n            'different': different,\n            'differences': differences\n        }\n    \n    def _compare_features(self):\n        \"\"\"Compare features between APKs\"\"\"\n        differences = []\n        \n        features1 = set(self.apk1.get('features', {}).get('required', []))\n        features2 = set(self.apk2.get('features', {}).get('required', []))\n        \n        only_in_1 = features1 - features2\n        only_in_2 = features2 - features1\n        \n        if only_in_1:\n            differences.append(f\"Features only in APK1: {', '.join(sorted(only_in_1))}\")\n        \n        if only_in_2:\n            differences.append(f\"Features only in APK2: {', '.join(sorted(only_in_2))}\")\n        \n        return differences\n    \n    def _compare_signatures(self):\n        \"\"\"Compare signature information including certificate fingerprints\"\"\"\n        sig1 = self.apk1.get('signature', {})\n        sig2 = self.apk2.get('signature', {})\n        \n        differences = []\n        match = True\n        \n        # Compare signer\n        signer1 = sig1.get('signer', 'Unknown')\n        signer2 = sig2.get('signer', 'Unknown')\n        if signer1 != signer2:\n            differences.append(f\"Signer: APK1='{signer1}' vs APK2='{signer2}'\")\n            match = False\n        \n        # Compare algorithm\n        algo1 = sig1.get('algorithm', 'Unknown')\n        algo2 = sig2.get('algorithm', 'Unknown')\n        if algo1 != algo2:\n            differences.append(f\"Algorithm: APK1='{algo1}' vs APK2='{algo2}'\")\n            match = False\n        \n        # Compare SHA-256 digest (most important for security)\n        sha256_1 = sig1.get('sha256_digest', 'Unknown')\n        sha256_2 = sig2.get('sha256_digest', 'Unknown')\n        if sha256_1 != sha256_2:\n            differences.append(f\"SHA-256 Digest: APK1='{sha256_1}' vs APK2='{sha256_2}'\")\n            match = False\n        \n        # Compare SHA-1 digest\n        sha1_1 = sig1.get('sha1_digest', 'Unknown')\n        sha1_2 = sig2.get('sha1_digest', 'Unknown')\n        if sha1_1 != sha1_2:\n            differences.append(f\"SHA-1 Digest: APK1='{sha1_1}' vs APK2='{sha1_2}'\")\n            match = False\n        \n        # Compare MD5 digest\n        md5_1 = sig1.get('md5_digest', 'Unknown')\n        md5_2 = sig2.get('md5_digest', 'Unknown')\n        if md5_1 != md5_2:\n            differences.append(f\"MD5 Digest: APK1='{md5_1}' vs APK2='{md5_2}'\")\n            match = False\n        \n        # Compare signature schemes\n        schemes1 = sig1.get('schemes', {})\n        schemes2 = sig2.get('schemes', {})\n        \n        for scheme in schemes1:\n            if scheme in schemes2:\n                if schemes1[scheme] != schemes2[scheme]:\n                    status1 = \"Verified\" if schemes1[scheme] else \"Not verified\"\n                    status2 = \"Verified\" if schemes2[scheme] else \"Not verified\"\n                    differences.append(f\"{scheme}: APK1={status1} vs APK2={status2}\")\n                    match = False\n        \n        return {\n            'match': match,\n            'differences': differences\n        }\n    \n    def _compare_components(self):\n        \"\"\"Compare app components (activities, services, etc.)\"\"\"\n        differences = []\n        \n        # Compare activities\n        activities1 = set(self.apk1.get('activities', []))\n        activities2 = set(self.apk2.get('activities', []))\n        \n        if activities1 != activities2:\n            only_1 = activities1 - activities2\n            only_2 = activities2 - activities1\n            \n            if only_1:\n                differences.append(f\"Activities only in APK1: {len(only_1)} components\")\n            if only_2:\n                differences.append(f\"Activities only in APK2: {len(only_2)} components\")\n        \n        # Compare services\n        services1 = set(self.apk1.get('services', []))\n        services2 = set(self.apk2.get('services', []))\n        \n        if services1 != services2:\n            only_1 = services1 - services2\n            only_2 = services2 - services1\n            \n            if only_1:\n                differences.append(f\"Services only in APK1: {len(only_1)} components\")\n            if only_2:\n                differences.append(f\"Services only in APK2: {len(only_2)} components\")\n        \n        return differences\n","size_bytes":7423},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"androguard>=4.1.3\",\n    \"cryptography>=45.0.6\",\n    \"pandas>=2.3.1\",\n    \"streamlit>=1.48.0\",\n]\n","size_bytes":243},"replit.md":{"content":"# Overview\n\nAPK Analysis Tool is a Streamlit-based web application for analyzing Android APK files. The tool provides comprehensive metadata extraction, security analysis, and comparison capabilities for Android applications. Users can upload APK files to examine their structure, permissions, features, signatures, and other technical details. The application supports single APK analysis, batch analysis of multiple APKs, and side-by-side comparison of two APKs with intelligent security concern detection.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Streamlit Web Framework**: The application uses Streamlit for the web interface, providing an interactive dashboard with file upload capabilities, data visualization, and comparison views\n- **Responsive Layout**: Wide layout configuration with expandable sidebar for mode selection\n- **Component-Based UI**: Modular interface with separate views for single analysis, batch analysis, and dual comparison modes\n- **Security Highlighting**: Real-time security concern detection with prominent warning display\n- **Batch Processing**: Progress tracking and summary statistics for multiple APK analysis\n\n## Backend Architecture\n- **Modular Analysis System**: Core functionality separated into specialized analyzer classes:\n  - `APKAnalyzer`: Main APK analysis engine using androguard library\n  - `SignatureAnalyzer`: Dedicated certificate and signature verification\n  - `APKComparator`: Side-by-side comparison logic for multiple APKs\n- **Data Processing Pipeline**: Sequential analysis workflow extracting metadata, permissions, features, and security information\n- **Error Handling**: Comprehensive exception handling with graceful degradation for partial analysis results\n\n## Data Processing\n- **APK Parsing**: Uses androguard library for deep APK structure analysis and bytecode examination\n- **Certificate Analysis**: Cryptography library integration for X.509 certificate parsing and signature scheme detection\n- **Metadata Extraction**: XML manifest parsing for application configuration and component discovery\n- **File Structure Analysis**: ZIP-based APK inspection for resource and binary analysis\n\n## Security Analysis\n- **Permission Analysis**: Comprehensive Android permission extraction and categorization\n- **Signature Verification**: Multi-scheme signature validation (v1-v4 APK signing schemes)\n- **Certificate Chain Analysis**: X.509 certificate validity and algorithm verification\n- **Debug Flag Detection**: Security configuration analysis for production readiness\n- **Target SDK Validation**: Ensures applications target API level 29 for security compliance\n- **Unity Export Verification**: Validates Unity main activity has required android:exported='true' attribute\n\n## Utility Functions\n- **Data Formatting**: Human-readable file size formatting and safe data access patterns\n- **Package Name Processing**: Standardized Android package identifier handling\n- **Permission Display**: Clean permission name formatting for user interface presentation\n\n# External Dependencies\n\n## Core Libraries\n- **Streamlit**: Web application framework for interactive dashboard creation\n- **Androguard**: Primary APK analysis library for Android application reverse engineering\n- **Cryptography**: Certificate parsing and signature verification functionality\n- **Pandas**: Data manipulation and tabular display in comparison views\n\n## System Dependencies\n- **Python Standard Library**: \n  - `zipfile` for APK file structure access\n  - `xml.etree.ElementTree` for Android manifest parsing\n  - `os` and `pathlib` for file system operations\n  - `tempfile` for secure temporary file handling\n  - `re` for pattern matching and string processing\n  - `datetime` for certificate validity period analysis\n\n## Android Analysis\n- **APK Structure Processing**: Direct ZIP file manipulation for resource extraction\n- **Manifest Analysis**: XML parsing for application metadata and component discovery\n- **Binary Analysis**: Native library architecture detection and Unity engine identification","size_bytes":4121},"signature_analyzer.py":{"content":"import zipfile\nimport os\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa, dsa, ec\nfrom cryptography.exceptions import InvalidSignature\nimport datetime\nimport hashlib\n\nclass SignatureAnalyzer:\n    def __init__(self, apk_path):\n        self.apk_path = apk_path\n        \n    def analyze(self):\n        \"\"\"Analyze APK signature and certificate details\"\"\"\n        try:\n            signature_data = {\n                'signer': 'Unknown',\n                'valid_from': 'Unknown',\n                'valid_until': 'Unknown',\n                'algorithm': 'Unknown',\n                'sha256_digest': 'Unknown',\n                'sha1_digest': 'Unknown',\n                'md5_digest': 'Unknown',\n                'schemes': {\n                    'v1 (JAR signing)': False,\n                    'v2 (APK Signature Scheme v2)': False,\n                    'v3 (APK Signature Scheme v3)': False,\n                    'v3.1 (APK Signature Scheme v3.1)': False,\n                    'v4 (APK Signature Scheme v4)': False\n                }\n            }\n            \n            # Extract certificate from META-INF\n            cert_data = self._extract_certificate()\n            if cert_data:\n                signature_data.update(cert_data)\n            \n            # Check signature schemes\n            signature_data['schemes'] = self._check_signature_schemes()\n            \n            return signature_data\n            \n        except Exception as e:\n            return {'error': str(e)}\n    \n    def _extract_certificate(self):\n        \"\"\"Extract certificate from APK's META-INF directory\"\"\"\n        try:\n            with zipfile.ZipFile(self.apk_path, 'r') as z:\n                # Look for certificate files\n                cert_files = [f for f in z.namelist() if f.startswith('META-INF/') and \n                            (f.endswith('.RSA') or f.endswith('.DSA') or f.endswith('.EC'))]\n                \n                if not cert_files:\n                    return None\n                \n                # Read the first certificate file\n                cert_file = cert_files[0]\n                cert_data = z.read(cert_file)\n                \n                # Parse the certificate (PKCS#7 format)\n                try:\n                    # Try to extract certificate from PKCS#7\n                    from cryptography.hazmat.primitives.serialization import pkcs7\n                    \n                    # This is a simplified approach - real PKCS#7 parsing would be more complex\n                    # For now, we'll extract basic information\n                    return self._parse_certificate_basic_info(cert_data, cert_file)\n                    \n                except Exception:\n                    # Fallback to basic parsing\n                    return self._parse_certificate_basic_info(cert_data, cert_file)\n                    \n        except Exception:\n            return None\n    \n    def _parse_certificate_basic_info(self, cert_data, filename):\n        \"\"\"Parse basic certificate information with improved PKCS#7 handling\"\"\"\n        try:\n            # Extract algorithm from filename\n            if filename.endswith('.RSA'):\n                algorithm = 'RSA with SHA-256'\n            elif filename.endswith('.DSA'):\n                algorithm = 'DSA with SHA-1'\n            elif filename.endswith('.EC'):\n                algorithm = 'ECDSA with SHA-256'\n            else:\n                algorithm = 'Unknown'\n            \n            # Try multiple approaches to extract certificate\n            cert = None\n            \n            # Approach 1: Try PKCS#7 parsing\n            try:\n                from cryptography.hazmat.primitives.serialization import pkcs7\n                from cryptography.hazmat.primitives import serialization\n                \n                # Try parsing as DER-encoded PKCS#7\n                certs = pkcs7.load_der_pkcs7_certificates(cert_data)\n                if certs and len(certs) > 0:\n                    cert = certs[0]\n            except Exception as e:\n                # PKCS#7 parsing failed, try other approaches\n                pass\n            \n            # Approach 2: Try parsing as raw X.509 certificate (sometimes certificates are embedded)\n            if cert is None:\n                try:\n                    from cryptography import x509\n                    from cryptography.hazmat.primitives import serialization\n                    \n                    # Look for DER-encoded certificate in the data\n                    # Sometimes the certificate is embedded in the PKCS#7 structure\n                    # Try to find certificate markers in the binary data\n                    \n                    # Search for ASN.1 certificate sequence starting bytes\n                    for i in range(len(cert_data) - 4):\n                        # Look for certificate sequence (0x30 followed by length)\n                        if cert_data[i:i+2] == b'\\x30\\x82':\n                            try:\n                                # Try parsing from this position\n                                remaining_data = cert_data[i:]\n                                cert = x509.load_der_x509_certificate(remaining_data)\n                                break\n                            except:\n                                continue\n                        elif cert_data[i:i+2] == b'\\x30\\x81':\n                            try:\n                                # Try parsing from this position (shorter length encoding)\n                                remaining_data = cert_data[i:]\n                                cert = x509.load_der_x509_certificate(remaining_data)\n                                break\n                            except:\n                                continue\n                except Exception:\n                    pass\n            \n            # If we successfully extracted a certificate, get its details\n            if cert is not None:\n                try:\n                    from cryptography.hazmat.primitives import serialization\n                    \n                    # Extract certificate details\n                    subject = cert.subject.rfc4514_string()\n                    issuer = cert.issuer.rfc4514_string()\n                    valid_from = cert.not_valid_before.strftime('%Y-%m-%d %H:%M:%S UTC')\n                    valid_until = cert.not_valid_after.strftime('%Y-%m-%d %H:%M:%S UTC')\n                    \n                    # Extract CN from subject\n                    subject_cn = \"Unknown\"\n                    for attribute in cert.subject:\n                        if attribute.oid._name == 'commonName':\n                            subject_cn = attribute.value\n                            break\n                    \n                    # Calculate certificate fingerprints\n                    try:\n                        cert_der = cert.public_bytes(serialization.Encoding.DER)\n                        sha256_digest = hashlib.sha256(cert_der).hexdigest()\n                        sha1_digest = hashlib.sha1(cert_der).hexdigest()\n                        md5_digest = hashlib.md5(cert_der).hexdigest()\n                        \n                        # Format fingerprints with colons for readability\n                        sha256_formatted = ':'.join(sha256_digest[i:i+2] for i in range(0, len(sha256_digest), 2)).upper()\n                        sha1_formatted = ':'.join(sha1_digest[i:i+2] for i in range(0, len(sha1_digest), 2)).upper()\n                        md5_formatted = ':'.join(md5_digest[i:i+2] for i in range(0, len(md5_digest), 2)).upper()\n                    except Exception as fingerprint_error:\n                        # If fingerprint calculation fails, set to debug info\n                        sha256_formatted = f\"Fingerprint calculation failed: {str(fingerprint_error)}\"\n                        sha1_formatted = \"Fingerprint calculation failed\"\n                        md5_formatted = \"Fingerprint calculation failed\"\n                    \n                    return {\n                        'signer': subject_cn,\n                        'valid_from': valid_from,\n                        'valid_until': valid_until,\n                        'algorithm': algorithm,\n                        'subject': subject,\n                        'issuer': issuer,\n                        'sha256_digest': sha256_formatted,\n                        'sha1_digest': sha1_formatted,\n                        'md5_digest': md5_formatted\n                    }\n                except Exception as cert_error:\n                    # Debug: capture what went wrong\n                    sha256_formatted = f\"Cert extraction failed: {str(cert_error)}\"\n                    sha1_formatted = \"Cert extraction failed\"\n                    md5_formatted = \"Cert extraction failed\"\n                    \n                    return {\n                        'signer': subject_cn if 'subject_cn' in locals() else 'Cert extracted but fingerprint failed',\n                        'valid_from': valid_from if 'valid_from' in locals() else 'Unknown',\n                        'valid_until': valid_until if 'valid_until' in locals() else 'Unknown',\n                        'algorithm': algorithm,\n                        'subject': subject if 'subject' in locals() else 'Unknown',\n                        'issuer': issuer if 'issuer' in locals() else 'Unknown',\n                        'sha256_digest': sha256_formatted,\n                        'sha1_digest': sha1_formatted,\n                        'md5_digest': md5_formatted\n                    }\n            \n            # Fallback: basic info with certificate file hash if no certificate could be extracted\n            # Calculate hash of the certificate file itself as a fallback\n            try:\n                sha256_file = hashlib.sha256(cert_data).hexdigest()\n                sha1_file = hashlib.sha1(cert_data).hexdigest()\n                md5_file = hashlib.md5(cert_data).hexdigest()\n                \n                sha256_formatted = ':'.join(sha256_file[i:i+2] for i in range(0, len(sha256_file), 2)).upper()\n                sha1_formatted = ':'.join(sha1_file[i:i+2] for i in range(0, len(sha1_file), 2)).upper()\n                md5_formatted = ':'.join(md5_file[i:i+2] for i in range(0, len(md5_file), 2)).upper()\n                \n                return {\n                    'signer': 'Certificate parsing failed - using file hash',\n                    'valid_from': 'Unknown',\n                    'valid_until': 'Unknown',\n                    'algorithm': algorithm,\n                    'sha256_digest': sha256_formatted + ' (file hash)',\n                    'sha1_digest': sha1_formatted + ' (file hash)',\n                    'md5_digest': md5_formatted + ' (file hash)'\n                }\n            except Exception:\n                pass\n            \n            # Final fallback\n            return {\n                'signer': 'Certificate found but parsing failed',\n                'valid_from': 'Unknown',\n                'valid_until': 'Unknown',\n                'algorithm': algorithm,\n                'sha256_digest': 'Unknown',\n                'sha1_digest': 'Unknown',\n                'md5_digest': 'Unknown'\n            }\n            \n        except Exception:\n            return {\n                'signer': 'Error parsing certificate',\n                'valid_from': 'Unknown',\n                'valid_until': 'Unknown',\n                'algorithm': 'Unknown',\n                'sha256_digest': 'Unknown',\n                'sha1_digest': 'Unknown',\n                'md5_digest': 'Unknown'\n            }\n    \n    def _check_signature_schemes(self):\n        \"\"\"Check which APK signature schemes are used\"\"\"\n        schemes = {\n            'v1 (JAR signing)': False,\n            'v2 (APK Signature Scheme v2)': False,\n            'v3 (APK Signature Scheme v3)': False,\n            'v3.1 (APK Signature Scheme v3.1)': False,\n            'v4 (APK Signature Scheme v4)': False\n        }\n        \n        try:\n            with zipfile.ZipFile(self.apk_path, 'r') as z:\n                # Check for v1 signature (JAR signing)\n                meta_inf_files = [f for f in z.namelist() if f.startswith('META-INF/')]\n                has_manifest = any(f.endswith('MANIFEST.MF') for f in meta_inf_files)\n                has_cert = any(f.endswith(('.RSA', '.DSA', '.EC')) for f in meta_inf_files)\n                \n                if has_manifest and has_cert:\n                    schemes['v1 (JAR signing)'] = True\n            \n            # Check for v2/v3/v4 signatures by examining the APK structure\n            # These would require parsing the APK Signing Block\n            schemes.update(self._check_apk_signing_block())\n            \n        except Exception:\n            pass\n        \n        return schemes\n    \n    def _check_apk_signing_block(self):\n        \"\"\"Check for APK Signing Block (v2, v3, v4 signatures)\"\"\"\n        schemes = {\n            'v2 (APK Signature Scheme v2)': False,\n            'v3 (APK Signature Scheme v3)': False,\n            'v3.1 (APK Signature Scheme v3.1)': False,\n            'v4 (APK Signature Scheme v4)': False\n        }\n        \n        try:\n            with open(self.apk_path, 'rb') as f:\n                # Read the end of the file to look for APK Signing Block\n                f.seek(-1024, 2)  # Go to near the end\n                data = f.read()\n                \n                # Look for APK Signature Block magic\n                if b'APK Sig Block 42' in data:\n                    # This is a very basic check - real implementation would parse the block\n                    schemes['v2 (APK Signature Scheme v2)'] = True\n                    \n                    # Check for newer scheme indicators\n                    # This is simplified - real parsing would be more complex\n                    if b'\\x03\\x01\\x00\\x00' in data:  # v3 indicator (simplified)\n                        schemes['v3 (APK Signature Scheme v3)'] = True\n                        \n        except Exception:\n            pass\n            \n        return schemes\n    \n    def get_certificate_details_advanced(self, cert_data):\n        \"\"\"Advanced certificate parsing (if needed)\"\"\"\n        try:\n            # This would implement full PKCS#7/certificate parsing\n            # For now, returning basic structure\n            return {\n                'subject': 'CN=Unknown',\n                'issuer': 'CN=Unknown',\n                'serial_number': 'Unknown',\n                'fingerprint_sha1': 'Unknown',\n                'fingerprint_sha256': 'Unknown',\n                'public_key_algorithm': 'Unknown',\n                'signature_algorithm': 'Unknown'\n            }\n        except Exception:\n            return {}\n","size_bytes":14756},"utils.py":{"content":"def format_size(bytes_size):\n    \"\"\"Format file size in human readable format\"\"\"\n    if bytes_size == 0:\n        return \"0 B\"\n    \n    units = ['B', 'KB', 'MB', 'GB', 'TB']\n    size = bytes_size\n    unit_index = 0\n    \n    while size >= 1024 and unit_index < len(units) - 1:\n        size /= 1024\n        unit_index += 1\n    \n    if unit_index == 0:\n        return f\"{int(size)} {units[unit_index]}\"\n    else:\n        return f\"{size:.2f} {units[unit_index]}\"\n\ndef safe_get(data, key, default=None):\n    \"\"\"Safely get value from dictionary with default\"\"\"\n    try:\n        if isinstance(data, dict):\n            return data.get(key, default)\n        else:\n            return default\n    except:\n        return default\n\ndef clean_package_name(package_name):\n    \"\"\"Clean and format package name\"\"\"\n    if not package_name or package_name == 'Unknown':\n        return 'Unknown'\n    \n    # Remove common prefixes if needed\n    if package_name.startswith('com.'):\n        return package_name\n    else:\n        return package_name\n\ndef format_permission_name(permission):\n    \"\"\"Format permission name for display\"\"\"\n    if not permission:\n        return 'Unknown'\n    \n    # Remove android.permission prefix for cleaner display\n    if permission.startswith('android.permission.'):\n        return permission[19:]  # Remove 'android.permission.' prefix\n    elif permission.startswith('com.android.'):\n        return permission[12:]  # Remove 'com.android.' prefix\n    else:\n        return permission\n\ndef format_feature_name(feature):\n    \"\"\"Format feature name for display\"\"\"\n    if not feature:\n        return 'Unknown'\n    \n    # Remove android.hardware prefix for cleaner display\n    if feature.startswith('android.hardware.'):\n        return feature[17:]  # Remove 'android.hardware.' prefix\n    elif feature.startswith('android.software.'):\n        return feature[17:]  # Remove 'android.software.' prefix\n    else:\n        return feature\n\ndef get_security_level(permissions):\n    \"\"\"Determine security risk level based on permissions\"\"\"\n    if not permissions:\n        return \"Low\", \"No sensitive permissions detected\"\n    \n    high_risk_permissions = [\n        'READ_CONTACTS', 'WRITE_CONTACTS',\n        'READ_CALENDAR', 'WRITE_CALENDAR',\n        'ACCESS_FINE_LOCATION', 'ACCESS_COARSE_LOCATION',\n        'RECORD_AUDIO', 'CAMERA',\n        'READ_PHONE_STATE', 'CALL_PHONE',\n        'READ_SMS', 'SEND_SMS', 'RECEIVE_SMS',\n        'WRITE_EXTERNAL_STORAGE',\n        'SYSTEM_ALERT_WINDOW',\n        'WRITE_SETTINGS'\n    ]\n    \n    medium_risk_permissions = [\n        'INTERNET', 'ACCESS_NETWORK_STATE',\n        'ACCESS_WIFI_STATE', 'CHANGE_WIFI_STATE',\n        'BLUETOOTH', 'BLUETOOTH_ADMIN',\n        'VIBRATE', 'WAKE_LOCK'\n    ]\n    \n    declared_perms = [format_permission_name(p) for p in permissions.get('declared', [])]\n    \n    high_risk_count = sum(1 for perm in declared_perms if perm in high_risk_permissions)\n    medium_risk_count = sum(1 for perm in declared_perms if perm in medium_risk_permissions)\n    \n    if high_risk_count >= 5:\n        return \"High\", f\"Multiple sensitive permissions detected ({high_risk_count} high-risk)\"\n    elif high_risk_count >= 2:\n        return \"Medium-High\", f\"Several sensitive permissions detected ({high_risk_count} high-risk)\"\n    elif high_risk_count >= 1:\n        return \"Medium\", f\"Some sensitive permissions detected ({high_risk_count} high-risk)\"\n    elif medium_risk_count >= 3:\n        return \"Medium-Low\", f\"Standard permissions with network access ({medium_risk_count} medium-risk)\"\n    else:\n        return \"Low\", \"Minimal permissions requested\"\n\ndef validate_apk_file(file):\n    \"\"\"Validate if uploaded file is a valid APK\"\"\"\n    if not file:\n        return False, \"No file provided\"\n    \n    if not file.name.lower().endswith('.apk'):\n        return False, \"File must have .apk extension\"\n    \n    # Check file size (limit to 100MB for this demo)\n    if file.size > 100 * 1024 * 1024:\n        return False, \"File size too large (max 100MB)\"\n    \n    return True, \"Valid APK file\"\n","size_bytes":4034},".streamlit/config.toml":{"content":"[server]\nheadless = true\naddress = \"0.0.0.0\"\nport = 5000\nmaxUploadSize = 500\n\n[theme]\nbase = \"light\"\n","size_bytes":101}}}